!--------------------------------------------------------------------
! **EcoSLIM** is a Lagrangian, particle-tracking that simulates advective
! and diffusive movement of water parcels. This code can be used to
! simulate age, diagnosing travel times, source water composition and
! flowpaths. It integrates seamlessly with **ParFlow-CLM**.
!--------------------------------------------------------------------
program EcoSLIM

use mpi
use cudafor
use ran_mod
use mrand
use thrust
use compact_array
use create_subgrid
use particles_loop
use mpiDeviceUtil

implicit none
!--------------------------------------------------------------------
! (1) Define variables
!--------------------------------------------------------------------
real(8),allocatable,pinned:: P(:,:)
        ! P = Particle array [np,attributes]
        ! np = Number of particles
        ! P(np,1) = X coordinate [L]
        ! P(np,2) = Y coordinate [L]
        ! P(np,3) = Z coordinate [L]
        ! P(np,4) = Particle residence time [T]
        ! P(np,5) = Saturated particle residence time [T]
        ! P(np,6) = Particle mass; assigned via preciptiation or snowmelt rate (Evap_Trans*density*volume*dT)
        ! P(np,7) = Particle source (1=IC, 2=rain, 3=snowmelt, 4=irrigation...)
        ! P(np,8) = Particle Status (1=active, 0=inactive)
        ! P(np,9) = concentration
        ! P(np,10) = Exit status (1=outflow, 2=ET...)

        ! P(np,11) = Length of flow path [L]
        ! P(np,12) = Length of saturated flow path [L]
        ! P(np,13:(12+nind)) = particle age in indicator i [T]
        ! P(np,(13+nind):(12+nind*2)) = Length of flow path in indicator i [L]

        ! ***the original CPU code make the age and length order wrong

        ! P(np,13+nind*2) = Particle Number (This is a unique integer identifier for the particle)
        ! P(np,14+nind*2) = Partical Initial X coordinate [L]
        ! P(np,15+nind*2) = Partical Initial Y coordinate [L]
        ! P(np,16+nind*2) = Partical Initial Z coordinate [L]
        ! P(np,17+nind*2) = Time that particle was added [T]

        ! ***The sequence of the attributes of P has been changed. Thus the time invariant attributes
        ! ***don't have to be sent to GPU.
        ! ***11/21/2021, after this update, P_de is a fixed length on GPU. We don't need to copy forth
        ! ***and back. We copy it back only when we output or restart.

real(8),allocatable,pinned:: Vx(:,:,:)
real(8),allocatable,pinned:: Vy(:,:,:)
real(8),allocatable,pinned:: Vz(:,:,:)
real(8),allocatable,pinned:: C(:,:,:,:)
character*20,allocatable:: conc_header(:)
real(8),allocatable:: Time_Next(:)
real(8),allocatable,pinned:: dz(:)
real(8),allocatable:: Zt(:)
real(8),allocatable,pinned:: Saturation(:,:,:)    ! Saturation (read from ParFlow)
real(8),allocatable,pinned:: Porosity(:,:,:)      ! Porosity (read from ParFlow)
real(8),allocatable,pinned:: EvapTrans(:,:,:)     ! CLM EvapTrans (read from ParFlow, [1/T] units)
real(8),allocatable:: EvapTrans_da(:,:,:)
real(8),allocatable:: CLMvars(:,:,:)     ! CLM Output (read from ParFlow, following single file
real(8),allocatable:: Pnts(:,:), DEM(:,:) ! DEM and grid points for concentration output
real(8),allocatable,pinned:: Ind(:,:,:)

!--------------------------------------------------------------------
integer Ploc(3), nind_c, itemp
integer nx_c, nnx, ny_c, nny, nz_c, nnz, nztemp
integer np_ic, np, np_active, jj, npnts, ncell, npout
integer n_constituents, pid
real(8) pfdt_c
integer pft1, pft2, tout1, pfnt, n_cycle
real(8) Time_first
integer kk, pfkk, outkk
integer ii, iflux_p_res, i_added_particles
integer i, j, k, l, ik, ji, m, ij, nzclm, nCLMsoil, ir

!--------------------------------------------------------------------
character(200) runname, filenum, filenumout, pname, fname, vtk_file, DEMname, Indname
real(8) Z, maxz, V_mult
logical clmtrans, clmfile, source1
real(8) Xmin_c, Xmax_c, Ymin_c, Ymax_c, Zmin_c, Zmax_c
real(8) dx_c, dy_c, Vpx, Vpy, Vpz
real(8) delta_time, dtfrac_c
real(8) mean_age, mean_comp, mean_mass, total_mass
real(8) denh2o_c, moldiff_c
real(8),allocatable:: PET_balance_da(:,:), PET_balance(:,:)
real(8) Total_time1, Total_time2, t1, t2, IO_time_read, IO_time_write
real(8) sort_time, redis_time, source_time, parallel_time
integer icwrite, ipwrite, ibinpntswrite, etwrite

!--------------------------------------------------------------------
integer,parameter:: tPB = 256
integer:: rank, t_rank, ierr, status(MPI_STATUS_SIZE)
integer:: np_ps, add_f, p_redis, path_c, nsub, cycle_f
integer:: fh0, fh1, fh2, fh3, fh4
character(len=MPI_MAX_PROCESSOR_NAME):: hostname
character(200):: loadf, restartf, exitedf, logf, message, ranknum
integer:: deviceID, namelength, np_active_log
integer(MPI_OFFSET_KIND):: offset
integer,allocatable:: nump(:),PME_tot(:,:,:),subid(:)
integer:: np_lo, np_ln, np_ro, np_rn

!--------------------------------------------------------------------
interface
    subroutine vtk_write(time,x,conc_header,ixlim,iylim,izlim,icycle,n_constituents,pnts,vtk_file)
        real*8                 :: time
        real*8                 :: x(:,:,:,:)
        character (len=20)     :: conc_header(:)
        integer*4              :: ixlim
        integer*4              :: iylim
        integer*4              :: izlim
        real*8                 :: dx
        real*8                 :: dy
        real*8                 :: dz(izlim)
        real*8                 :: pnts(:,:)
        integer                :: icycle
        integer                :: n_constituents
        character (len=200)    :: vtk_file
    end subroutine vtk_write

    subroutine vtk_write_points(p,np_active,np,icycle,vtk_file,dx,dy,nx,ny,maxz,dem)
        real*8                 :: p(:,:)
        integer                :: icycle
        integer*4              :: np_active
        integer*4              :: np
        integer                :: n_constituents
        real*8                 :: dx
        real*8                 :: dy
        integer*4              :: nx
        integer*4              :: ny
        real*8                 :: maxz
        real*8                 :: dem(:,:)
        character (len=200)    :: vtk_file
    end subroutine vtk_write_points
end interface

!--------------------------------------------------------------------
call MPI_INIT(ierr)
call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr)
call MPI_COMM_SIZE(MPI_COMM_WORLD, t_rank, ierr)
write(ranknum,'(i5.5)') rank

! Get and set unique device
call assignDevice(deviceID)
call MPI_GET_PROCESSOR_NAME(hostname, namelength, ierr)
write(message,"('[',i2.2 ,'] host: ', a, ', device: ', i2.2, a)") &
rank, trim(hostname), deviceID, new_line(' ')
offset = len(trim(message))*rank

call MPI_FILE_OPEN(MPI_COMM_WORLD, 'Device_Utility.txt', &
MPI_MODE_WRONLY + MPI_MODE_CREATE, MPI_INFO_NULL, fh0, ierr)
call MPI_FILE_SEEK(fh0,offset,MPI_SEEK_SET,ierr)
call MPI_FILE_WRITE(fh0,message,len(trim(message)),MPI_CHARACTER, &
    MPI_STATUS_IGNORE, ierr)
call MPI_FILE_CLOSE(fh0, ierr)

!--------------------------------------------------------------------
! Set up timing
Total_time1 = 0.d0
Total_time2 = 0.d0
t1 = 0.d0
t2 = 0.d0
IO_time_read = 0.d0
IO_time_write = 0.d0
parallel_time = 0.d0
sort_time = 0.d0
redis_time = 0.d0
source_time = 0.d0

call MPI_BARRIER(MPI_COMM_WORLD, ierr)
Total_time1 = MPI_Wtime()

!--------------------------------------------------------------------
! (2) Read inputs, set up domain, write the log file, and
! initialize particles
!--------------------------------------------------------------------
call MPI_BARRIER(MPI_COMM_WORLD, ierr)
T1 = MPI_Wtime()

! open SLIM input .txt file
open(10,file='slimin.txt')

! read SLIM run name
read(10,*) runname

! read ParFlow run name
read(10,*) pname

! read DEM file name
read(10,*) DEMname

if(rank == 0) then
    ! open/create/write the output log.txt file. If doesn't exist, it's created.
    open(11,file = trim(runname)//'_log.txt')
    write(11,*) '### EcoSLIM Log File'
    write(11,*)
    write(11,*) 'run name:',trim(runname)
    write(11,*)
    write(11,*) 'ParFlow run name:',trim(pname)
    write(11,*)
    if (DEMname /= '') then
        write(11,*) 'ParFlow DEM name:',trim(DEMname)
    else
        write(11,*) 'Not reading ParFlow DEM'
    end if
    write(11,*)
endif ! rank = 0

! read domain number of cells and number of particles to be injected
read(10,*) nx_c
nx = nx_c
read(10,*) ny_c
ny = ny_c
read(10,*) nz_c
nz = nz_c
read(10,*) nCLMsoil
read(10,*) ppx
read(10,*) qqy
read(10,*) p_redis
! read(10,*) source1
read(10,*) path_c
path = path_c
read(10,*) cycle_f
read(10,*) np_ic

! read in the number of particles total
read(10,*) np

if(rank == 0) then
    ! check to make sure we don't assign more particles for IC than we have allocated in total
    if (np_ic > np) then
        write(11,*) 'warning NP_IC greater than IC'
        np = np_ic
    end if
    ! write nx, ny, nz, and np in the log file
    write(11,*) 'Grid information'
    write(11,*) 'nx:',nx_c
    write(11,*) 'ny:',ny_c
    write(11,*) 'nz:',nz_c
    write(11,*)
    write(11,*) 'Particle IC Information'
    write(11,*) 'np IC:',np_ic
    if (np_ic == -1) &
        write(11,*) 'Reading particle restart file:',trim(runname)//'_particle_restart.bin'
    write(11,*) 'np:',np
endif ! rank=0

! grid + 1 variables
nnx = nx_c + 1
nny = ny_c + 1
nnz = nz_c + 1
nzclm = 13 + nCLMsoil
n_constituents = 9
! allocate arrays
allocate(DEM(nx_c,ny_c),nump(ppx*qqy),grid(ppx*qqy,4))
allocate(dz(nz_c),Zt(0:nz_c))
allocate(Vx(nnx,ny_c,nz_c),Vy(nx_c,nny,nz_c),Vz(nx_c,ny_c,nnz))
allocate(Saturation(nx_c,ny_c,nz_c),Porosity(nx_c,ny_c,nz_c),EvapTrans(nx_c,ny_c,nz_c),Ind(nx_c,ny_c,nz_c))
allocate(EvapTrans_da(nx_c,ny_c,nz_c))
allocate(CLMvars(nx_c,ny_c,nzclm))
allocate(C(n_constituents,nx_c,ny_c,nz_c))
allocate(conc_header(n_constituents))
allocate(PME_tot(nx_c,ny_c,1),nump_path(nx_c,ny_c,1))
! Intialize everything to Zero
Vx = 0.0d0
Vy = 0.0d0
Vz = 0.0d0

Saturation = 0.0d0
Porosity   = 0.0d0
EvapTrans  = 0.0d0
EvapTrans_da = 0.0d0
C = 0.0d0

allocate(out_np_cpu(1),ET_np_cpu(1))
allocate(out_age_cpu(1),out_mass_cpu(1),out_comp_cpu(3))
allocate(ET_age_cpu(1),ET_mass_cpu(1),ET_comp_cpu(3))

! read dx_c, dy_c as scalars
read(10,*) dx_c
dx = dx_c
read(10,*) dy_c
dy = dy_c
! read dz as an array
read(10,*) dz(1:nz_c)
! read in (constant for now) ParFlow dt
read(10,*) pfdt_c
pfdt = pfdt_c
! read in parflow start and stop times
read(10,*) pft1
read(10,*) pft2
read(10,*) tout1
read(10,*) n_cycle
read(10,*) add_f

pfnt = n_cycle*(pft2-pft1+1)
outkk = tout1 + 1

! set ET DT to ParFlow one and allocate ET arrays accordingly
allocate(PET_balance(pfnt,2))
allocate(PET_balance_da(pfnt,2))
PET_balance = 0.0d0
PET_balance_da = 0.0d0

! IO control, each value is a timestep interval, e.g. 1= every timestep, 2=every other, 0 = no writing
read(10,*) ipwrite        ! controls an ASCII, .3D particle file not recommended due to poor performance
read(10,*) ibinpntswrite  !  controls VTK, binary output of particle locations and attributes
read(10,*) etwrite        !  controls ASCII ET output
read(10,*) icwrite        ! controls VTK, binary grid based output where particle masses, concentrations,
                          ! ages are mapped to a grid and written every N timesteps

! allocate and assign timesteps
allocate(Time_Next(pfnt))
Time_Next = 0.d0
do kk = outkk, pfnt
    Time_Next(kk) = dble(kk)*pfdt_c
end do
Time_first = dble(outkk-1)*pfdt_c

read(10,*) V_mult
read(10,*) clmtrans
read(10,*) clmfile
read(10,*) iflux_p_res
read(10,*) denh2o_c
denh2o = denh2o_c
read(10,*) moldiff_c
moldiff = moldiff_c
read(10,*) dtfrac_c
dtfrac = dtfrac_c

if(rank == 0) then
    ! wite out log file
    write(11,*)
    write(11,*) 'Grid Dimensions'
    write(11,'(" dx:",e12.5)') dx_c
    write(11,'(" dy:",e12.5)') dy_c
    write(11,'(" dz:",*(e12.5,", "))') dz(1:nz_c)
    write(11,*)
    write(11,*) 'Timestepping Information'
    write(11,'(" ParFlow delta-T, pfdt:",e12.5)') pfdt_c
    write(11,'(" ParFlow timesteps, pfnt:",i12)') pfnt
    write(11,'(" ParFlow start step, pft1:",i12)') pft1
    write(11,'(" ParFlow end step, pft2:",i12)') pft2
    write(11,'(" Output step start:",i12)') outkk
    write(11,'(" Time loops, cycles, n_cycle:",i12)') n_cycle
    write(11,'(" Total time steps:",i12)') pfnt

    write(11,*)
    write(11,*) 'V mult: ',V_mult,' for forward/backward particle tracking'
    write(11,*) 'CLM Trans: ',clmtrans,' adds / removes particles based on LSM fluxes'
    write(11,*)
    write(11,*) 'Physical Constants'
    write(11,*) 'denh2o: ',denh2o_c,' M/L^3'
    write(11,*) 'Molecular Diffusivity: ',moldiff_c,' '
    write(11,*)
    write(11,*) 'Numerical Stability Information'
    write(11,'(" dtfrac: ",e12.5," fraction of dx/Vx")') dtfrac_c
endif

read(10,*) nind_c
nind = nind_c
read(10,*) Indname
if(rank == 0) then
    write(11,*)
    write(11,*) 'Indicator File'
    write(11,'(i," Indicators")') nind_c
endif

! end of SLIM input
close(10)

DEM = 0.0d0
nztemp = 1
! read in DEM
if (DEMname /= '') then
    fname = trim(adjustl(DEMname))
    call pfb_read(DEM,fname,nx_c,ny_c,nztemp)
end if ! DEM

Ind = 1.0d0
! read in Indicator file
if (nind_c > 0) then
  if (Indname /= '') then
    fname = trim(adjustl(Indname))
    call pfb_read(Ind,fname,nx_c,ny_c,nz_c)
    if(rank == 0) write(11,*) 'Read Indicator File:', fname
  else
    if(rank == 0) &
      write(11,*) 'WARNING: indicator flag > 0 but no indicator file provided'
  end if
end if

if(rank == 0) then
    flush(11)
    close(11)
endif

! Read porosity values from ParFlow .pfb file
fname=trim(adjustl(pname))//'.out.porosity.pfb'
call pfb_read(Porosity,fname,nx_c,ny_c,nz_c)

! Read initial Saturation from ParFlow
kk = 0
pfkk = pft1 - 1
write(filenum,'(i5.5)') pfkk
fname=trim(adjustl(pname))//'.out.satur.'//trim(adjustl(filenum))//'.pfb'
call pfb_read(Saturation,fname,nx_c,ny_c,nz_c)

allocate(P(np,17+nind_c*2))
P = 0.0            ! clear out all particle attributes
P(1:np,7:9) = 1.0  ! make all particles active to start with and original from 1 = GW/IC

open(10,file='sub_info.txt')
    do i = 1, t_rank
        if(rank == i-1) then
            read(10,*) nsub
            if(nsub > 0) then
                allocate(subid(nsub))
                read(10,*) (subid(j),j = 1,nsub)
            else
                read(10,*)
            endif
        else
            read(10,*)
            read(10,*)
        endif
    enddo
close(10)

call MPI_BARRIER(MPI_COMM_WORLD, ierr)
T2 = MPI_Wtime()
IO_time_read = IO_time_read + (T2-T1)

! set up domain boundaries
Xmin_c = 0.0d0
Ymin_c = 0.0d0
Zmin_c = 0.0d0
Xmax_c = dble(nx_c)*dx_c
Ymax_c = dble(ny_c)*dy_c
Zmax_c = 0.0d0
do k = 1, nz_c
    Zmax_c = Zmax_c + dz(k)
end do

Xmin = Xmin_c
Ymin = Ymin_c
Zmin = Zmin_c
Xmax = Xmax_c
Ymax = Ymax_c
Zmax = Zmax_c

write(restartf,'(a,i3.3,a)') 'Particle_restart.',rank,'.bin'
write(exitedf,'(a,i3.3,a)') 'Exited_particles.',rank,'.bin'

open(30,file='Load_info.'//trim(adjustl(ranknum))//'.txt')

write(30,*) '## Domain Info'
write(30,'("Xmin:",e12.5," Xmax:",e12.5)') Xmin_c, Xmax_c
write(30,'("Ymin:",e12.5," Ymax:",e12.5)') Ymin_c, Ymax_c
write(30,'("Zmin:",e12.5," Zmax:",e12.5)') Zmin_c, Zmax_c

call gridinfo(nx_c,ny_c)
! add grid info to log file
write(30,'(a,i5,a,4(i10,1x))') 'rank:',rank,', Gridinfo (ix1,iy1,nnx1,nny1):',grid(rank+1,1:4)
flush(30)

! Set up grid locations for file output
npnts=nnx*nny*nnz
ncell=nx_c*ny_c*nz_c

allocate(Pnts(npnts,3))
Pnts=0
m=1

! Need the maximum height of the model and elevation locations
Z = 0.0d0
Zt(0) = 0.0d0
do ik = 1, nz_c
  Z = Z + dz(ik)
  Zt(ik) = Z
  ! print*, Z, dz(ik), Zt(ik), ik
end do
maxZ=Z

    ! candidate loops for OpenMP
    do k = 1, nnz
        do j = 1, nny
            do i = 1, nnx
                Pnts(m,1) = dble(i-1)*dx_c
                Pnts(m,2) = dble(j-1)*dy_c
                ! This is a simple way of handling the maximum edges
                if (i <= nx_c) then
                    ii = i
                else
                    ii = nx_c
                endif
                if (j <= ny_c) then
                    jj = j
                else
                    jj = ny_c
                endif
                ! This step translates the DEM
                ! The specified initial heights in the pfb (z1) are ignored and the
                ! offset is computed based on the model thickness
                Pnts(m,3) = (DEM(ii,jj) - maxZ) + Zt(k-1)
                m = m + 1
            end do
        end do
    end do

    ! Intialize random seed
    ir = -3333

    ! Define initial particles' locations and mass
    if (np_ic > 0)  then
    np_active = 0
    pid = 0
    do k = 1, nz_c
        do j = grid(rank+1,2)+1,grid(rank+1,2)+grid(rank+1,4) !iy1+1,iy1+nny1 !1, ny
        do i = grid(rank+1,1)+1,grid(rank+1,1)+grid(rank+1,3) !ix1+1,ix1+nnx1 !1, nx
            if (np_active < np) then   ! check if we have particles left
            if (Saturation(i,j,k) > 0.0) then ! check if we are in the active domain
                do ij = 1, np_ic
                np_active = np_active + 1
                pid = pid + 1
                ii = np_active
                P(ii,13+2*nind_c) = dble(pid) ! Saving a particle ID number
                ! assign X, Y, Z locations randomly to each cell
                ! assign X, Y, Z locations randomly to each cell
                P(ii,1) = dble(i-1)*dx_c + ran1(ir)*dx_c
                P(ii,14+2*nind_c) = P(ii,1) ! Saving the initial location
                P(ii,2) = dble(j-1)*dy_c + ran1(ir)*dy_c
                P(ii,15+2*nind_c) = P(ii,2)
                P(ii,17+2*nind_c) = tout1 ! setting insert time to the start time

                Z = 0.0d0
                do ik = 1, k
                    Z = Z + dz(ik)
                end do

                P(ii,3) = Z - dz(k)*ran1(ir)
                P(ii,16+2*nind_c) = P(ii,3)

                ! assign mass of particle by the volume of the cells
                ! and the water contained in that cell
                P(ii,6) = dx_c*dy_c*dz(k)*(Porosity(i,j,k)*Saturation(i,j,k))*denh2o_c*(1.0d0/dble(np_ic))
                P(ii,7) = 1.0d0
                P(ii,8) = 1.0d0
                ! set up intial concentrations
                C(1,i,j,k) = C(1,i,j,k) + P(ii,8)*P(ii,6) / &
                    (dx_c*dy_c*dz(k)*(Porosity(i,j,k)*Saturation(i,j,k)))
                C(2,i,j,k) = C(2,i,j,k) + P(ii,8)*P(ii,4)*P(ii,6)
                C(4,i,j,k) = C(4,i,j,k) + P(ii,8)*P(ii,7)*P(ii,6)
                C(3,i,j,k) = C(3,i,j,k) + P(ii,8)*P(ii,6)
                end do   ! particles per cell
            end if   !  active domain
            else
            write(30,*) ' **Warning IC input but no paricles left'
            write(30,*) ' **Exiting code gracefully writing restart'
            goto 9090
            end if
        end do ! i
        end do ! j
    end do ! k

    ! if np_ic = -1 then we read a restart file
    else if (np_ic == -1) then

        write(30,'(a,a,i3.3,a)') 'Reading particle restart File:','Particle_restart.',rank,'.bin'
        ! read in full particle array as binary restart file, should name change?,
        ! potential overwrite confusion
        call MPI_FILE_OPEN(MPI_COMM_SELF,restartf,MPI_MODE_RDONLY,MPI_INFO_NULL,fh2,ierr)

        call MPI_FILE_READ(fh2,np_active,1,MPI_INTEGER,MPI_STATUS_IGNORE,ierr)
        call MPI_FILE_READ(fh2,pid,1,MPI_INTEGER,MPI_STATUS_IGNORE,ierr)

        if (np_active < np) then   ! check if we have particles left
            call MPI_FILE_READ(fh2,P(1:np_active,1:nind_c*2+17),np_active*(nind_c*2+17), &
            MPI_DOUBLE_PRECISION,MPI_STATUS_IGNORE,ierr)
            call MPI_FILE_CLOSE(fh2, ierr)

            write(30,'(a,i10.10)') 'RESTART np_active:',np_active
            write(30,'(a,i10.10)') 'RESTART pid:',pid
        else
            call MPI_FILE_CLOSE(fh2, ierr)
            write(30,*) ' **Warning restart IC input but no paricles left'
            write(30,*) ' **Exiting code *not* (over)writing restart'
            stop
        end if

    end if

    ! Define initial particles' locations by surface water
    !
    if (np_ic < -1)  then
        np_active = 0
        pid = np_active
        ir = -3333
        k = nz_c
        do j = grid(rank+1,2)+1,grid(rank+1,2)+grid(rank+1,4) !iy1+1,iy1+nny1 !1, ny
            do i = grid(rank+1,1)+1,grid(rank+1,1)+grid(rank+1,3) !ix1+1,ix1+nnx1 !1, nx
                if (np_active < np) then   ! check if we have particles left
                    ! if (saturation(i,j,k) >= 0.95d0)  then
                    do ij = 1, abs(np_ic)
                    np_active = np_active + 1
                    pid = pid +1
                    ii = np_active
                    P(ii,13+2*nind_c)=dble(pid) !Saving a particle ID number
                    ! assign X, Y, Z locations randomly to each cell
                    ! assign X, Y, Z locations randomly to each cell
                    P(ii,1) = dble(i-1)*dx_c  +ran1(ir)*dx_c
                    P(ii,14+2*nind_c)=P(ii,1) ! Saving the initial location
                    P(ii,2) = dble(j-1)*dy_c  +ran1(ir)*dy_c
                    P(ii,15+2*nind_c)=P(ii,2)
                    P(ii,17+2*nind_c) = outkk + 0.0 !setting insert time to the start time

                    Z = 0.0d0
                    do ik = 1, k
                        Z = Z + dz(ik)
                    end do

                    P(ii,3) = Z !-dz(k)*ran1(ir)
                    P(ii,16+2*nind_c)=P(ii,3)

                    ! assign mass of particle by the volume of the cells
                    ! and the water contained in that cell
                    P(ii,6) = dx_c*dy_c*dz(k)*(Porosity(i,j,k)  &
                        *Saturation(i,j,k))*denh2o_c*(1.0d0/dble(np_ic))
                    P(ii,7) = 1.0d0
                    P(ii,8) = 1.0d0
                    ! set up intial concentrations
                    C(1,i,j,k) = C(1,i,j,k) + P(ii,8)*P(ii,6) /  &
                        (dx_c*dy_c*dz(k)*(Porosity(i,j,k)        &
                        *Saturation(i,j,k)))
                    C(2,i,j,k) = C(2,i,j,k) + P(ii,8)*P(ii,4)*P(ii,6)
                    C(4,i,j,k) = C(4,i,j,k) + P(ii,8)*P(ii,7)*P(ii,6)
                    C(3,i,j,k) = C(3,i,j,k) + P(ii,8)*P(ii,6)
                    end do   ! particles per cell
                    !end if  !! saturated at top
                else
                    write(30,*) ' **Warning IC input but no paricles left'
                    write(30,*) ' **Exiting code gracefully writing restart'
                    goto 9090
                end if
            end do ! i
        end do ! j
    end if ! river IC

    ! Write out intial concentrations
    ! normalize ages by mass
    call MPI_ALLReduce(MPI_IN_PLACE,C,n_constituents*nx_c*ny_c*nz_c,MPI_DOUBLE_PRECISION, &
                    MPI_SUM,MPI_COMM_WORLD,ierr)

    where (C(3,:,:,:)>0.0)  C(2,:,:,:) = C(2,:,:,:) / C(3,:,:,:)
    where (C(3,:,:,:)>0.0)  C(4,:,:,:) = C(4,:,:,:) / C(3,:,:,:)

    ! Set up output options for VTK grid output
    ! icwrite = 1
    vtk_file=trim(runname)//'_cgrid'
    conc_header(1) = 'Concentration'
    conc_header(2) = 'Age'
    conc_header(3) = 'Mass'
    conc_header(4) = 'Comp'
    conc_header(5) = 'Delta'
    conc_header(6) = 'ET_Npart'
    conc_header(7) = 'ET_Mass'
    conc_header(8) = 'ET_Age'
    conc_header(9) = 'ET_Comp'

    if(icwrite > 0 .and. rank == 0) &
    call vtk_write(Time_first,C,conc_header,nx_c,ny_c,nz_c,0,n_constituents,Pnts,vtk_file)

    ! clear out C arrays
    ! C = 0.0D0

    open(31,file='Log_particles.'//trim(adjustl(ranknum))//'.txt')
    write(31,*) ' **** Transient Simulation Particle Accounting ****'
    write(31,*) ' Timestep PFTimestep OutStep Time Mean_Age Mean_Comp Mean_Mass Total_Mass &
    PrecipIn ETOut NP_PrecipIn NP_ETOut NP_QOut NP_active_old NP_filtered'

    ! open exited partile file and write header
    call MPI_FILE_OPEN(MPI_COMM_SELF,exitedf,MPI_MODE_WRONLY+MPI_MODE_CREATE,MPI_INFO_NULL,fh3,ierr)

    if(rank == 0) then
        if(ipwrite < 0) then
            ! open/create/write the 3D output file which will write particles out each timestemp, very slowly in parallel
            open(214,file=trim(runname)//'_total_particle_trace.3D')
            write(214,*) 'X Y Z TIME'
        end if !! ipwrite < 0

        open(13,file=trim(runname)//'_ET_output.txt')
        write(13,*) 'TIME ET_age ET_comp1 ET_comp2 ET_comp3 ET_mass ET_Np'

        open(15,file=trim(runname)//'_flow_output.txt')
        write(15,*) 'TIME Out_age Out_comp1 outcomp2 outcomp3 Out_mass Out_NP'

        open(16,file=trim(runname)//'_PET_balance.txt')
        write(16,*) 'TIME P[kg] ET[kg]'
    endif

    ! call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    ! T1 = MPI_Wtime()
    ! if(source1) then
    !     call grid_PME(nx,ny_c,nz_c,pname,pft1,pft2,iflux_p_res,PME_tot)
    !     call grid_adjust(nx,ny_c,1,PME_tot)
    ! endif
    ! call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    ! T2 = MPI_Wtime()
    ! source_time = T2 - T1

    allocate(dz_de(nz_c))
    allocate(Vx_de(nnx,ny_c,nz_c),Vy_de(nx_c,nny,nz_c),Vz_de(nx_c,ny_c,nnz),Ind_de(nx_c,ny_c,nz_c))
    allocate(Saturation_de(nx_c,ny_c,nz_c),Porosity_de(nx_c,ny_c,nz_c),EvapTrans_de(nx_c,ny_c,nz_c))
    allocate(C_de(n_constituents,nx_c,ny_c,nz_c),d_indices(np),d_isValid(np),h(np))
    allocate(out_np_de(1),ET_np_de(1),nump_path_de(nx_c,ny_c,1))
    allocate(out_age_de(1),out_mass_de(1),out_comp_de(3))
    allocate(ET_age_de(1),ET_mass_de(1),ET_comp_de(3))
    allocate(mean_age_de(1),mean_comp_de(1),total_mass_de(1))
    dz_de = dz
    Ind_de = Ind
    Porosity_de = Porosity
    allocate(P_de(np,17+nind_c*2))
    P_de(1:np_active,:) = P(1:np_active,:)

    EvapTrans_T  => EvapTrans_de
    Saturation_T => Saturation_de
    Porosity_T   => Porosity_de
    Vx_T  => Vx_de
    Vy_T  => Vy_de
    Vz_T  => Vz_de
    Ind_T => Ind_de
    dz_T  => dz_de

    call createRand_loop<<< ceiling(dble(np)/tPB),tPB >>> (np, rank, pfnt)
!--------------------------------------------------------------------
! (3) For each timestep, loop over all particles to find and
!     update their new locations
!--------------------------------------------------------------------
! loop over timesteps
pfkk = mod((outkk-1),(pft2-pft1+1))+pft1-1

do kk = outkk, pfnt

    ! reset ParFlow counter for cycles
    if (mod((kk-1),(pft2-pft1+1)) == 0)  pfkk = pft1 - 1

    if(cycle_f > 0) then
        if(mod(kk-1,cycle_f) == 0) then
            subid(1) = subid(1) + 1
            if(subid(1) + 1 > t_rank) subid(1) = mod(subid(1),t_rank) ! plus twice
            write(30,'(a,i5,a,4(i10,1x))') 'rank:',rank, &
            ', Gridinfo (ix1,iy1,nnx1,nny1):',grid(subid(1)+1,1:4)
            flush(30)
        endif
    endif

    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    T1 = MPI_Wtime()
    ! adjust the file counters
    pfkk = pfkk + 1

    ! Read the velocities computed by ParFlow
    write(filenum,'(i5.5)') pfkk

    fname=trim(adjustl(pname))//'.out.velx.'//trim(adjustl(filenum))//'.pfb'
    call pfb_read(Vx,fname,nx_c+1,ny_c,nz_c)

    fname=trim(adjustl(pname))//'.out.vely.'//trim(adjustl(filenum))//'.pfb'
    call pfb_read(Vy,fname,nx_c,ny_c+1,nz_c)

    fname=trim(adjustl(pname))//'.out.velz.'//trim(adjustl(filenum))//'.pfb'
    call pfb_read(Vz,fname,nx_c,ny_c,nz_c+1)

    fname=trim(adjustl(pname))//'.out.satur.'//trim(adjustl(filenum))//'.pfb'
    call pfb_read(Saturation,fname,nx_c,ny_c,nz_c)

    if (clmtrans) then
        ! Read in the Evap_Trans
        fname=trim(adjustl(pname))//'.out.evaptrans.'//trim(adjustl(filenum))//'.pfb'
        call pfb_read(EvapTrans,fname,nx_c,ny_c,nz_c)

        if (mod((kk-1),add_f) == 0) EvapTrans_da = 0.d0
        where (EvapTrans > 0.d0) EvapTrans_da = EvapTrans_da + EvapTrans

        ! check if we read full CLM output file
        if (clmfile) then
            ! Read in CLM output file @RMM to do make this input
            fname=trim(adjustl(pname))//'.out.clm_output.'//trim(adjustl(filenum))//'.C.pfb'
            call pfb_read(CLMvars,fname,nx_c,ny_c,nzclm)
        end if
    end if

    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    T2 = MPI_Wtime()
    IO_time_read = IO_time_read + (T2-T1)

    ! Determine whether to perform forward or backward patricle tracking
    Vx = Vx * V_mult
    Vy = Vy * V_mult
    Vz = Vz * V_mult

    i_added_particles = 0
    if (clmtrans) then
        if (np_active < np) then
            do m = 1, nsub
            do k = 1, nz_c
            do j = grid(subid(m)+1,2)+1,grid(subid(m)+1,2)+grid(subid(m)+1,4) !iy3+1,iy3+nny3 !1, ny !rank id
            do i = grid(subid(m)+1,1)+1,grid(subid(m)+1,1)+grid(subid(m)+1,3) !ix3+1,ix3+nnx3 !1, nx
                if (EvapTrans(i,j,k) > 0.0d0) then
                    ! sum water inputs in PET 1 = P, 2 = ET, kk= PF timestep
                    ! units of ([T]*[1/T]*[L^3])/[M/L^3] gives Mass of water input
                    PET_balance(kk,1) = PET_balance(kk,1) + pfdt_c*EvapTrans(i,j,k)*dx_c*dy_c*dz(k)*denh2o_c
                else !! ET not P
                    ! sum water inputs in PET 1 = P, 2 = ET, kk= PF timestep
                    ! units of ([T]*[1/T]*[L^3])/[M/L^3] gives Mass of water input
                    PET_balance(kk,2) = PET_balance(kk,2) + pfdt_c*EvapTrans(i,j,k)*dx_c*dy_c*dz(k)*denh2o_c
                end if !! end if for P-ET > 0

                if(mod(kk,add_f) == 0) then
                    if(EvapTrans_da(i,j,k) > 0.0d0) then
                        PET_balance_da(kk,1) = PET_balance_da(kk,1) + pfdt_c*EvapTrans_da(i,j,k)*dx_c*dy_c*dz(k)*denh2o_c
                        do ji = 1, iflux_p_res
                            if (np_active + i_added_particles < np) then   ! check if we have particles left
                            ! np_active = np_active + 1
                            pid = np_active + 1
                            ii = i_added_particles + 1             ! increase total number of particles
                            P(ii,13+2*nind_c) = dble(pid)
                            i_added_particles = i_added_particles + 1   ! increase particle counter for accounting
                            ! assign X, Y locations randomly to recharge cell
                            P(ii,1) = dble(i-1)*dx_c + ran1(ir)*dx_c
                            P(ii,14+2*nind_c) = P(ii,1) ! Saving the initial location
                            P(ii,2) = dble(j-1)*dy_c + ran1(ir)*dy_c
                            P(ii,15+2*nind_c) = P(ii,2) ! Saving the initial location
                            Z = 0.0d0
                            do ik = 1, k
                                Z = Z + dz(ik)
                            end do
                            ! Z location is fixed
                            P(ii,3) = Z - dz(k)*0.5d0 !  *ran1(ir)
                            P(ii,16+2*nind_c) = P(ii,3) ! Saving the initial location

                            P(ii,4) = 0.0d0
                            if (iflux_p_res >= 0) then
                                P(ii,4) = 0.0d0 + ran1(ir)*pfdt_c
                                if (nind_c > 0) then
                                    Ploc(1) = floor(P(ii,1) / dx_c)
                                    Ploc(2) = floor(P(ii,2) / dy_c)
                                    Ploc(3) = nz_c-1
                                    itemp=idnint(Ind(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))
                                    if(itemp > 0 .and. itemp <= nind_c) then
                                        P(ii,(12+itemp)) = P(ii,(12+itemp)) + P(ii,4)
                                    end  if
                                end if
                            end if

                            P(ii,5) = 0.0d0
                            P(ii,17+2*nind_c) = dble((kk-1))*pfdt_c + P(ii,4) !recording particle insert time
                            P(ii,6) = (1.0d0/dble(abs(iflux_p_res)))*pfdt_c*EvapTrans_da(i,j,k)*dx_c*dy_c*dz(k)*denh2o_c  !! units of ([T]*[1/T]*[L^3])/[M/L^3] gives Mass
                            !! check if input is rain or snowmelt
                            if(CLMvars(i,j,11) > 0.0) then !this is snowmelt
                                P(ii,7) = 3.0d0 ! Snow composition
                            else
                                P(ii,7) = 2.d0 ! Rainfall composition
                            end if
                            P(ii,8) = 1.0d0   ! make particle active
                            P(ii,9) = 1.0d0
                            P(ii,10) = 0.0d0  ! Particle hasn't exited domain

                            else
                                write(30,*) ' **Warning rainfall input but no paricles left'
                                write(30,*) ' **Exiting code gracefully writing restart'
                                goto 9090
                            end if  !! do we have particles left?
                        end do !! for flux particle resolution
                    else
                        PET_balance_da(kk,2) = PET_balance_da(kk,2) + pfdt_c*EvapTrans_da(i,j,k)*dx_c*dy_c*dz(k)*denh2o_c
                    end if
                end if

            end do
            end do
            end do
            end do

        end if  !! second particle check to avoid array loop if we are out of particles
    end if  !! end if for clmtrans logical

    call MPI_ALLReduce(MPI_IN_PLACE, PET_balance_da(kk,:), 2,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
    call MPI_ALLReduce(MPI_IN_PLACE, PET_balance(kk,:),    2,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
!--------------------------------------------------------------------
    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    T1 = MPI_Wtime()

    if(i_added_particles > 0) then
        P_de(np_active+1:np_active+i_added_particles,:) = P(1:i_added_particles,:)
        np_active = np_active + i_added_particles
    endif

    if(path_c > 0 .and. mod(kk,path_c) == 0) nump_path_de = 0

    out_age_de = 0.d0; out_mass_de = 0.d0; out_comp_de = 0.d0; out_np_de = 0
    et_age_de  = 0.d0; et_mass_de  = 0.d0; et_comp_de  = 0.d0; et_np_de  = 0; C_de = 0.d0

    Vx_de   = Vx;        Vy_de   = Vy;        Vz_de   = Vz
    Saturation_de = Saturation;  EvapTrans_de = EvapTrans

    call particles_independent <<< ceiling(dble(np_active)/tPB),tPB >>> (kk,np_active)

    C              = C_de
    out_age_cpu    = out_age_de;    out_mass_cpu   = out_mass_de
    out_comp_cpu   = out_comp_de;   out_np_cpu     = out_np_de
    et_age_cpu     = et_age_de;     et_mass_cpu    = et_mass_de
    et_comp_cpu    = et_comp_de;    et_np_cpu      = et_np_de

    call MPI_ALLReduce(MPI_IN_PLACE, ET_age_cpu,  1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
    call MPI_ALLReduce(MPI_IN_PLACE, ET_comp_cpu, 3,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
    call MPI_ALLReduce(MPI_IN_PLACE, ET_mass_cpu, 1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
    call MPI_ALLReduce(MPI_IN_PLACE, ET_np_cpu,   1,MPI_INTEGER,         MPI_SUM,MPI_COMM_WORLD,ierr)

    call MPI_ALLReduce(MPI_IN_PLACE, Out_age_cpu, 1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
    call MPI_ALLReduce(MPI_IN_PLACE, Out_comp_cpu,3,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
    call MPI_ALLReduce(MPI_IN_PLACE, Out_mass_cpu,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)
    call MPI_ALLReduce(MPI_IN_PLACE, Out_np_cpu,  1,MPI_INTEGER,         MPI_SUM,MPI_COMM_WORLD,ierr)

    call MPI_ALLReduce(MPI_IN_PLACE,C,n_constituents*nx_c*ny_c*nz_c,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)

    if(path_c > 0 .and. mod(kk,path_c) == 0) then
        nump_path = nump_path_de
        call MPI_ALLReduce(MPI_IN_PLACE,nump_path,nx_c*ny_c,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,ierr)
        !nump_path = nump_path/1000
        call grid_adjust(nx_c,ny_c,1,nump_path)
        write(30,'(a,i5,a,4(i10,1x))') 'rank:',rank,', Gridinfo (ix1,iy1,nnx1,nny1):',grid(rank+1,1:4)
        flush(30)
    endif

    call MPI_Reduce(np_active, np_active_log, 1, MPI_INTEGER, MPI_SUM, 0, MPI_COMM_WORLD, ierr)

    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    T2 = MPI_Wtime()
    parallel_time = parallel_time + (T2-T1)
!--------------------------------------------------------------------
    if(rank == 0) then
        write(12,*) np_active_log, T2-T1, redis_time
        if(path_c > 0 .and. mod(kk,path_c) == 0) then
            write(12,'(5(20i10,/))') ((nump_path(i,j,1),i=1,nx_c),j=1,ny_c)
        endif
        flush(12)

        if (ET_mass_cpu(1) > 0) then
            ET_age_cpu(1)  = ET_age_cpu(1)/ET_mass_cpu(1)
            ET_comp_cpu(:) = ET_comp_cpu(:)/ET_mass_cpu(1)
        end if
        write(13,'(6(e12.5),i12)') dble(kk)*pfdt_c,ET_age_cpu(1),ET_comp_cpu(1), &
            ET_comp_cpu(2),ET_comp_cpu(3),ET_mass_cpu(1),ET_np_cpu(1)
        flush(13)

        if (Out_mass_cpu(1) > 0) then
            Out_age_cpu(1)  = Out_age_cpu(1)/Out_mass_cpu(1)
            Out_comp_cpu(:) = Out_comp_cpu(:)/Out_mass_cpu(1)
        end if
        write(15,64) dble(kk)*pfdt_c,Out_age_cpu(1),Out_comp_cpu(1), &
            Out_comp_cpu(2),Out_comp_cpu(3),Out_mass_cpu(1),Out_np_cpu(1)
        flush(15)

        write(16,'(5(e12.5,2x))') dble(kk)*pfdt_c,PET_balance(kk,1),PET_balance(kk,2), &
            PET_balance_da(kk,1),PET_balance_da(kk,2)
        flush(16)
    endif

!--------------------------------------------------------------------
    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    T1 = MPI_Wtime()

    write(filenumout,'(i10.10)') kk

    ! write all active particles at concentration in ASCII VisIT 3D file format
    ! as noted above, this option is very slow compared to VTK binary output
    if(ipwrite > 0) then
        if(mod(kk,ipwrite) == 0)  then
            ! open/create/write the 3D output file
            open(14,file=trim(runname)//'_transient_particle.'//trim(adjustl(filenumout))//'.3D')
            write(14,*) 'X Y Z TIME ID'
            do ii = 1, np_active
            if (P(ii,8) == 1) write(14,61) P(ii,1), P(ii,2), P(ii,3), P(ii,4), P(ii,13+2*nind_c)
            end do
            close(14)
        end if
    end if

    ! normalize ages by mass
    ! where (C(3,:,:,:)>0.0)  C(2,:,:,:) = C(2,:,:,:) / C(3,:,:,:)
    ! where (C(3,:,:,:)>0.0)  C(4,:,:,:) = C(4,:,:,:) / C(3,:,:,:)
    ! where (C(3,:,:,:)>0.0)  C(5,:,:,:) = C(5,:,:,:) / C(3,:,:,:)

    ! normalize ET ages by mass
    where (C(7,:,:,:)>0.0)  C(8,:,:,:) = C(8,:,:,:) / C(7,:,:,:)
    where (C(7,:,:,:)>0.0)  C(9,:,:,:) = C(9,:,:,:) / C(7,:,:,:)

    ! Write gridded ET outputs to text files
    if(etwrite > 0) then
        if (mod(kk,etwrite) == 0) then
            ! open/create/write the 3D output file
            open(14,file=trim(runname)//'_ET_summary.'//trim(adjustl(filenumout))//'.txt')
                write(14,*) 'X Y Z ET_npart, ET_mass, ET_age, ET_comp, EvapTrans_Rate, Saturation, Porosity'
                do i = 1, nx_c
                    do j = 1, ny_c
                        do k = 1, nz_c
                        if (EvapTrans(i,j,k) < 0.0d0) &
                            write(14,'(3(i6),7(e13.5))') i,j,k,C(6,i,j,k),C(7,i,j,k),C(8,i,j,k), &
                            C(9,i,j,k),EvapTrans(i,j,k),Saturation(i,j,k),Porosity(i,j,k)
                        end do
                    end do
                end do
            close(14)
        end if
    end if

    ! write grid based values ("concentrations")
    vtk_file=trim(runname)//'_cgrid'
    if(icwrite > 0)  then
        !if(mod(kk,icwrite) == 0)  &
        !call vtk_write(Time_Next(kk),C,conc_header,nx_c,ny_c,nz_c,kk,n_constituents,Pnts,vtk_file)
        if(mod(kk,icwrite) == 0 .and. rank == 0)  then
            fname=trim(runname)//'.out.C1.'//trim(adjustl(filenumout))//'.pfb'
            call pfb_write(C,fname,nx_c,ny_c,nz_c,dx_c,dy_c,dy_c,n_constituents,1)
            fname=trim(runname)//'.out.C2.'//trim(adjustl(filenumout))//'.pfb'
            call pfb_write(C,fname,nx_c,ny_c,nz_c,dx_c,dy_c,dy_c,n_constituents,2)
            fname=trim(runname)//'.out.C3.'//trim(adjustl(filenumout))//'.pfb'
            call pfb_write(C,fname,nx_c,ny_c,nz_c,dx_c,dy_c,dy_c,n_constituents,3)
            fname=trim(runname)//'.out.C4.'//trim(adjustl(filenumout))//'.pfb'
            call pfb_write(C,fname,nx_c,ny_c,nz_c,dx_c,dy_c,dy_c,n_constituents,4)
            fname=trim(runname)//'.out.C5.'//trim(adjustl(filenumout))//'.pfb'
            call pfb_write(C,fname,nx_c,ny_c,nz_c,dx_c,dy_c,dy_c,n_constituents,5)
            !fname=trim(runname)//'.out.C6.'//trim(adjustl(filenumout))//'.pfb'
            !call pfb_write(C,fname,nx_c,ny_c,nz_c,dx_c,dy_c,dy_c,n_constituents,6)
            !fname=trim(runname)//'.out.C7.'//trim(adjustl(filenumout))//'.pfb'
            !call pfb_write(C,fname,nx_c,ny_c,nz_c,dx_c,dy_c,dy_c,n_constituents,7)
            !fname=trim(runname)//'.out.C8.'//trim(adjustl(filenumout))//'.pfb'
            !call pfb_write(C,fname,nx_c,ny_c,nz_c,dx_c,dy_c,dy_c,n_constituents,8)
            !fname=trim(runname)//'.out.C9.'//trim(adjustl(filenumout))//'.pfb'
            !call pfb_write(C,fname,nx_c,ny_c,nz_c,dx_c,dy_c,dy_c,n_constituents,9)
        end if
    end if

    ! write binary particle locations and attributes
    vtk_file=trim(runname)//'_pnts'
    if(ibinpntswrite > 0) then
        if(mod(kk,ibinpntswrite) == 0) &
            call vtk_write_points(P,np_active,np,kk,vtk_file,dx_c,dy_c,nx_c,ny_c,maxZ,dem)
    end if

    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    T2 = MPI_Wtime()
    IO_time_write = IO_time_write + (T2-T1)
!--------------------------------------------------------------------
    call prepare_neighbor<<<ceiling(dble(np_active)/tPB),tPB>>>( &
    P_de(1:np_active,8),d_isValid,np_active)
    ! can't use P_de(1:np_active,8) as indicator directly, since it will need
    ! a lot of real(8) to integer conversion which is time consuming.

    call thrustscan(d_isValid,np_active,d_indices)
    itemp = d_indices(np_active)
    npout = np_active - itemp

    if(npout > 0) then
        allocate(holes(npout),P_exit(npout,17+2*nind_c))
        ! P_exit has to be deallocated after the use in main
        call prepare_holes<<<ceiling(dble(np_active)/tPB),tPB>>>( &
            holes,d_indices,d_isValid,np_active)
        call select2exit<<<ceiling(dble(npout)/tPB),tPB>>>( &
            holes,P_de,P_exit,npout)
        call compaction_inplace<<<ceiling(dble(np_active)/tPB),tPB>>>( &
            holes,d_indices,d_isValid,P_de,np_active)
        ! update the slots after np_active
        np_active = itemp
        ! add output if necessary
        deallocate(holes,P_exit)
    end if

    mean_age_de = 0.d0
    mean_comp_de = 0.d0
    total_mass_de = 0.d0

    call Update_mass<<< ceiling(dble(np_active)/tPB),tPB >>>( &
    P_de,mean_age_de,mean_comp_de,total_mass_de,np_active)

    mean_age = mean_age_de(1)
    mean_comp = mean_comp_de(1)
    total_mass = total_mass_de(1)

    if (total_mass > 0.0d0)  then
        mean_age =  mean_age / total_mass
        mean_comp = mean_comp / total_mass
        mean_mass = total_mass / dble(np_active)
    end if

    write(31,'(3(i10),7(1x,e12.5,1x),3(i8),i12)') kk,pfkk,outkk,Time_Next(kk),mean_age,mean_comp, &
    mean_mass,total_mass,PET_balance(kk,1),PET_balance(kk,2),i_added_particles,ET_np_cpu(1), &
    Out_np_cpu(1),np_active
    flush(31)
!------------------------------------------------------------------
    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    T1 = MPI_Wtime()

    if(p_redis > 0 .and. mod(kk,p_redis) == 0) then

        P = P_de

        call MPI_ALLGather(np_active,1,MPI_INTEGER,nump,1,MPI_INTEGER,MPI_COMM_WORLD,ierr)
        np_lo = sum(nump(1:rank)); np_ro = sum(nump(1:rank+1))
        np_ps = (sum(nump)+t_rank-mod(sum(nump),t_rank))/t_rank
        np_ln = rank*np_ps; np_rn = (rank+1)*np_ps

        if(np_lo < np_ln .and. rank > 0) then
            !P(1:np_ln-np_lo,:), Send to rank-1
            !  ___|___|___|___......
            !    old     new
            call MPI_SEND(P(1:np_ln-np_lo,:), &
            (np_ln-np_lo)*(17+nind_c*2),MPI_DOUBLE_PRECISION, &
            rank-1,40,MPI_COMM_WORLD,ierr)
            P(1:np_active-(np_ln-np_lo),:) = P(np_ln-np_lo+1:np_active,:)
            np_active = np_active - (np_ln-np_lo)

            write(30,'(i10,1x,a,i3,1x,a,i3,1x)') np_ln-np_lo, &
            'particles sent from rank',rank,'to rank',rank-1
            flush(30)
        endif

        if(np_ro < np_rn .and. rank < t_rank-1) then
            !P(np_active+1:np_active+np_rn-np_ro,:), Receive from rank+1
            !  ......___|___|___|___
            !          old     new
            !warnings/stop if np_active+np_rn-np_ro > np
            call MPI_RECV(P(np_active+1:np_active+np_rn-np_ro,:), &
            (np_rn-np_ro)*(17+nind_c*2),MPI_DOUBLE_PRECISION, &
            rank+1,40,MPI_COMM_WORLD,status,ierr)
            np_active = np_active + np_rn-np_ro

            write(30,'(i10,1x,a,i3,1x,a,i3,1x)') np_rn-np_ro, &
            'particles received on rank',rank,'from rank',rank+1
            flush(30)
        endif

        if(np_ro > np_rn .and. rank < t_rank-1) then
            !P(np_active-(np_ro-np_rn)+1:np_active,:), Send to rank+1
            !  ......___|___|___|___
            !          new     old
            call MPI_SEND(P(np_active-(np_ro-np_rn)+1:np_active,:), &
            (np_ro-np_rn)*(17+nind_c*2),MPI_DOUBLE_PRECISION, &
            rank+1,45,MPI_COMM_WORLD,ierr)
            !P(np_active-(np_ro-np_rn)+1:np_active,8) = 0.d0 !May not necessary
            np_active = np_active - (np_ro-np_rn)

            write(30,'(i10,1x,a,i3,1x,a,i3,1x,a)') np_ro-np_rn, &
            'particles sent from rank',rank,'to rank',rank+1
            flush(30)
        endif

        if(np_lo > np_ln .and. rank > 0) then
            !P(1:np_lo-np_ln,:), Receive from rank-1
            !  ___|___|___|___......
            !    new     old
            !warnings/stop if np_active+np_lo-np_ln > np
            P(1+np_lo-np_ln:np_active+np_lo-np_ln,:) = P(1:np_active,:)
            np_active = np_active + np_lo-np_ln
            call MPI_RECV(P(1:np_lo-np_ln,:), &
            (np_lo-np_ln)*(17+nind_c*2),MPI_DOUBLE_PRECISION, &
            rank-1,45,MPI_COMM_WORLD,status,ierr)

            write(30,'(i10,1x,a,i3,1x,a,i3,1x)') np_lo-np_ln, &
            'particles received on rank',rank,'from rank',rank-1
            flush(30)
        endif

        P_de = P

    endif

    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    T2 = MPI_Wtime()
    redis_time = redis_time + (T2-T1)
!------------------------------------------------------------------
    if (mod(kk,(pft2-pft1+1)/5) == 0)  then
        P = P_de
        call MPI_FILE_OPEN(MPI_COMM_SELF,restartf,MPI_MODE_WRONLY+MPI_MODE_CREATE, &
                        MPI_INFO_NULL,fh2,ierr)
        call MPI_FILE_WRITE(fh2,np_active,1,MPI_INTEGER,MPI_STATUS_IGNORE,ierr)
        call MPI_FILE_WRITE(fh2,pid,1,MPI_INTEGER,MPI_STATUS_IGNORE,ierr)
        call MPI_FILE_WRITE(fh2,P(1:np_active,1:nind_c*2+17),np_active*(nind_c*2+17), &
                            MPI_DOUBLE_PRECISION,MPI_STATUS_IGNORE,ierr)
        call MPI_FILE_CLOSE(fh2, ierr)
    end if

    end do !! timesteps and cycles

    9090 continue  !! continue statement for running out of particles when assigning precip flux.
                !!  code exits gracefully (writes files and possibly a restart file so the user can
                !!  re-run the simulation)

    nullify(EvapTrans_T,Saturation_T,Porosity_T)
    nullify(Vx_T,Vy_T,Vz_T,Ind_T,dz_T)

    ! close output file
    flush(31); close(31)
    call MPI_FILE_CLOSE(fh3, ierr)

    ! format statements for particle output
    61  FORMAT(4(e12.5))
    64  FORMAT(6(e12.5),i12)

    if(rank == 0) then
        flush(13)
        close(13)

        if(ipwrite < 0) close(214)

        flush(15)
        close(15)

        flush(16)
        close(16)
    endif

    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    Total_time2 = MPI_Wtime()

    write(30,*)
    write(30,*) '###  Execution Finished'
    write(30,*)
    write(30,'(i10,a)') npout,' particles exited the domain via outflow or ET.'
    write(30,*)
    write(30,*) 'Simulation Timing and Profiling:'
    write(30,'("Total Execution Time (s):",e12.5)') Total_time2-Total_time1
    write(30,'("File IO Time Read (s):",e12.5)') IO_time_read
    write(30,'("File IO Time Write (s):",e12.5)') IO_time_write
    write(30,'("Time Sorting (s):",e12.5)') sort_time
    write(30,'("Parallel Particle Time (s):",e12.5)') parallel_time
    write(30,*)

    flush(30); close(30)
    call MPI_FINALIZE(ierr)

end program EcoSLIM

