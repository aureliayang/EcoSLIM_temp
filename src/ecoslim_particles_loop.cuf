module particles_loop
    use cudafor
    use curand_device
    use mrand, only: h
    real(8),allocatable,device::P_de(:,:),C_de(:,:,:,:)
    real(8),allocatable,device::Vx_de(:,:,:),Vy_de(:,:,:),Vz_de(:,:,:),dz_de(:),Ind_de(:,:,:)
    real(8),allocatable,device::Saturation_de(:,:,:),Porosity_de(:,:,:),EvapTrans_de(:,:,:)
    integer,allocatable,device::out_np_de(:),ET_np_de(:),nump_path_de(:,:,:)
    real(8),allocatable,device::out_age_de(:),out_mass_de(:),out_comp_de(:)
    real(8),allocatable,device::ET_age_de(:),ET_mass_de(:),ET_comp_de(:)

    real(8),allocatable,device::mean_age_de(:),mean_comp_de(:),total_mass_de(:)
    real(8),allocatable,device::P_exit(:,:)
    integer,allocatable,device::holes(:)
    integer,allocatable,device::d_indices(:),d_isValid(:)

    integer,allocatable,pinned::out_np_cpu(:),ET_np_cpu(:),nump_path(:,:,:)
    real(8),allocatable,pinned::out_age_cpu(:),out_mass_cpu(:),out_comp_cpu(:)
    real(8),allocatable,pinned::ET_age_cpu(:),ET_mass_cpu(:),ET_comp_cpu(:)

    !real(8),constant::xmin,ymin,zmin,xmax,ymax,zmax
    !real(8),constant::pfdt,moldiff,dx,dy,denh2o,dtfrac
    !integer,constant::path,kk,np_active,nx,ny,nz,nind
contains
 attributes(global) subroutine particles_independent( &
     kk,np_active,nx,ny,nz,nind,path, &
     pfdt,moldiff,dx,dy,denh2o,dtfrac, &
     xmin,ymin,zmin,xmax,ymax,zmax)

 ! P,C,dz,EvapTrans,Vx,Vy,Vz,nump_path,Saturation,Porosity,&
 ! out_age,out_mass,out_comp,et_age,et_mass,et_comp,&
 ! out_np,et_np,Ind,

  implicit none

  integer,value:: kk,np_active,nx,ny,nz,nind,path
  real(8),value:: pfdt,moldiff,dx,dy,denh2o,dtfrac
  real(8),value:: xmin,ymin,zmin,xmax,ymax,zmax


  integer:: ii,k,Ploc(3)
  real(8):: Z,Vpx,Vpy,Vpz,particledt,delta_time,et_flux, &
  water_vol,advdt(3),z1,z2,z3,temp,lock
  type(curandStateXORWOW):: hh

  ! change et_flux and water_vol to k and Z

  lock = 1.d0
!=============================================================================
    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

    delta_time = 0.d0

    hh = h(ii)

    if(P_de(ii,8) == 1. .and. ii <= np_active) then

        delta_time = P_de(ii,4) + pfdt

        do while (P_de(ii,4) < delta_time)

            ! Find the "adjacent" cell corresponding to the particle's location
            Ploc(1) = floor(P_de(ii,1) / dx)
            Ploc(2) = floor(P_de(ii,2) / dy)

            Z = 0.d0
            do k = 1, nz
                Z = Z + dz_de(k)
                if (Z >= P_de(ii,3)) then
                    Ploc(3) = k - 1
                    exit
                end if
            end do

            ! check to make sure particles are in central part of the domain and if not
            ! apply some boundary condition to them
            ! check if particles are in domain, need to expand this to include better treatment of BC's
            if ((P_de(ii,1) < Xmin).or.(P_de(ii,2) < Ymin).or.(P_de(ii,3) < Zmin).or.  &
            (P_de(ii,1) >= Xmax).or.(P_de(ii,2) >= Ymax).or.(P_de(ii,3) >= (Zmax-dz_de(nz)))) then

            if ((P_de(ii,3) >= Zmax-(dz_de(nz)*0.5d0)).and. &
            (Saturation_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) == 1.).and. &
             (Vz_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) > 0.d0)) then

            temp = atomicAdd(Out_age_de(1), P_de(ii,4)*P_de(ii,6))
            temp = atomicAdd(Out_mass_de(1), P_de(ii,6))

            if (P_de(ii,7) == 1.) then
            temp = atomicAdd(Out_comp_de(1), P_de(ii,6))
            end if

            if (P_de(ii,7) == 2.) then
            temp = atomicAdd(Out_comp_de(2), P_de(ii,6))
            end if

            if (P_de(ii,7) == 3.) then
            temp = atomicAdd(Out_comp_de(3), P_de(ii,6))
            end if

            temp = atomicAdd(Out_np_de(1), idnint(lock))

            ! flag particle as inactive
            P_de(ii,8) = 0.d0
            ! flag as exiting via Outflow
            P_de(ii,10) = 1.d0
            goto 999

            end if
            ! otherwise we just leave it in the domain to reflect
            end if

            ! Find each particle's factional cell location
            advdt(1) = (P_de(ii,1) - dble(Ploc(1))*dx) / dx
            advdt(2) = (P_de(ii,2) - dble(Ploc(2))*dy) / dy

            Z = 0.d0
            do k = 1, Ploc(3)
                Z = Z + dz_de(k)
            end do
            advdt(3) = (P_de(ii,3) - Z) / dz_de(Ploc(3) + 1)

            ! Calculate local particle velocity using linear interpolation,
            ! converting darcy flux to average linear velocity

            Vpx = ((1.-advdt(1))*Vx_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                  + Vx_de(Ploc(1)+2,Ploc(2)+1,Ploc(3)+1)*advdt(1))   &
                  /(Porosity_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                  *Saturation_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            Vpy = ((1.-advdt(2))*Vy_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                    + Vy_de(Ploc(1)+1,Ploc(2)+2,Ploc(3)+1)*advdt(2)) &
                    /(Porosity_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                    *Saturation_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            Vpz = ((1.-advdt(3))*Vz_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                      + Vz_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+2)*advdt(3))  &
                        /(Porosity_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                      *Saturation_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            ! calculate particle dt
            ! check each direction independently
            advdt = pfdt
            if (Vpx /= 0.) advdt(1) = abs(dtfrac*(dx/Vpx))
            if (Vpy /= 0.) advdt(2) = abs(dtfrac*(dy/Vpy))
            if (Vpz /= 0.) advdt(3) = dtfrac*(dz_de(Ploc(3)+1)/abs(Vpz))

            particledt = min(advdt(1), advdt(2), advdt(3), &
                      pfdt*dtfrac, delta_time-P_de(ii,4))

            ! calculate Flux in cell and compare it with the ET flux out of the cell
            if (EvapTrans_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) < 0.d0)then
            ! calculate ET flux volumetrically and compare to
            et_flux = abs(EvapTrans_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))*dx*dy*dz_de(Ploc(3)+1)

            ! compare total water removed from cell by ET with total water available in cell to arrive at a particle
            ! probability of being captured by roots
            ! water volume in cell
            water_vol = dx*dy*dz_de(Ploc(3)+1)*(Porosity_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
            *Saturation_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            if (curand_uniform(hh) < ((et_flux*particledt)/water_vol)) then   ! check if particle is 'captured' by the roots
            ! this section made atomic since it could inovlve a data race
            ! that is, each thread can only update the ET arrays one at a time

            temp = atomicAdd(ET_age_de(1), P_de(ii,4)*P_de(ii,6))

            temp = atomicAdd(ET_mass_de(1), P_de(ii,6))

            if (P_de(ii,7) == 1.) then
            temp = atomicAdd(ET_comp_de(1), P_de(ii,6))
            end if

            if (P_de(ii,7) == 2.) then
            temp = atomicAdd(ET_comp_de(2), P_de(ii,6))
            end if

            if (P_de(ii,7) == 3.) then
            temp = atomicAdd(ET_comp_de(3), P_de(ii,6))
            end if

            temp = atomicAdd(ET_np_de(1), idnint(lock))

            ! outputting spatially distributed ET information
            temp = atomicAdd(C_de(6,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),lock)

            temp = atomicAdd(C_de(7,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_de(ii,6)) ! particle mass added to ET

            temp = atomicAdd(C_de(8,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_de(ii,4)*P_de(ii,6))  ! mass weighted age

            temp = atomicAdd(C_de(9,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_de(ii,7)*P_de(ii,6))  ! mass weighted contribution

            ! now remove particle from domain
            P_de(ii,8)  = 0.d0
            ! flag as exiting via ET
            P_de(ii,10) = 2.d0

            goto 999
            end if
            end if

            ! Advect particle to new location using Euler advection until next time
            P_de(ii,1) = P_de(ii,1) + particledt * Vpx
            P_de(ii,2) = P_de(ii,2) + particledt * Vpy
            P_de(ii,3) = P_de(ii,3) + particledt * Vpz
            P_de(ii,4) = P_de(ii,4) + particledt

            temp = SQRT((particledt*Vpx)**2 + (particledt*Vpy)**2 + &
                         (particledt*Vpz)**2)

            ! Molecular Diffusion
            if (moldiff > 0.d0) then
            z1 = 2.d0*SQRT(3.d0)*(curand_uniform(hh)-0.5d0)
            z2 = 2.d0*SQRT(3.d0)*(curand_uniform(hh)-0.5d0)
            z3 = 2.d0*SQRT(3.d0)*(curand_uniform(hh)-0.5d0)

            P_de(ii,1) = P_de(ii,1) + z1 * SQRT(moldiff*2.d0*particledt)
            P_de(ii,2) = P_de(ii,2) + z2 * SQRT(moldiff*2.d0*particledt)
            P_de(ii,3) = P_de(ii,3) + z3 * SQRT(moldiff*2.d0*particledt)

            temp = temp + &
                         SQRT((z1*SQRT(moldiff*2.d0*particledt))**2 + &
                              (z2*SQRT(moldiff*2.d0*particledt))**2 + &
                              (z3*SQRT(moldiff*2.d0*particledt))**2)
            end if
            P_de(ii,11) = P_de(ii,11) + temp
            ! placeholder for other interactions; potentially added later
            !
            ! place to track saturated / groundwater time if needed
            if(Saturation_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) == 1.) then
              P_de(ii,5) = P_de(ii,5) + particledt
              P_de(ii,12) = P_de(ii,12) + temp
            end if

            if (nind > 0) then
              k = idnint(Ind_de(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))
              if(k > 0 .and. k <= nind) then
                P_de(ii,12+k) = P_de(ii,12+k) + particledt

                P_de(ii,12+nind+k) = P_de(ii,12+nind+k) + temp
              end if
            end if

            ! simple reflection boundary
            if (P_de(ii,3) >=Zmax) P_de(ii,3) = Zmax- (P_de(ii,3) - Zmax)
            if (P_de(ii,1) >=Xmax) P_de(ii,1) = Xmax- (P_de(ii,1) - Xmax)
            if (P_de(ii,2) >=Ymax) P_de(ii,2) = Ymax- (P_de(ii,2) - Ymax)
            if (P_de(ii,2) <=Ymin) P_de(ii,2) = Ymin+ (Ymin - P_de(ii,2))
            if (P_de(ii,3) <=Zmin) P_de(ii,3) = Zmin+ (Zmin - P_de(ii,3))
            if (P_de(ii,1) <=Xmin) P_de(ii,1) = Xmin+ (Xmin - P_de(ii,1))

        end do  ! end of do-while loop for particle time to next time
        999 continue   ! where we go if the particle is out of bounds

        if(path > 0 .and. mod(kk,path) == 0) then

            Z = 0.d0
            do k = 1, nz
                Z = Z + dz_de(k)
                if (Z >= P_de(ii,15+2*nind)) then
                    Ploc(3) = k - 1
                    exit
                end if
            end do

            if(Ploc(3)+1 == nz) then
                Ploc(1) = floor(P_de(ii,13+2*nind) / dx)
                Ploc(2) = floor(P_de(ii,14+2*nind) / dy)
                temp = atomicAdd(nump_path_de(Ploc(1)+1,Ploc(2)+1,1),idnint(P_de(ii,8)))
            endif

        endif

        ! concentration routine
        ! Find the "adjacent" "cell corresponding to the particle's location
        Ploc(1) = floor(P_de(ii,1) / dx)
        Ploc(2) = floor(P_de(ii,2) / dy)
        Z = 0.d0
        do k = 1, nz
            Z = Z + dz_de(k)
            if (Z >= P_de(ii,3)) then
                Ploc(3) = k - 1
                exit
            end if
        end do
        temp = atomicAdd(C_de(1,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_de(ii,8)*P_de(ii,11)*P_de(ii,6))
        temp = atomicAdd(C_de(2,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_de(ii,8)*P_de(ii,4)*P_de(ii,6))
        temp = atomicAdd(C_de(4,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_de(ii,8)*P_de(ii,5)*P_de(ii,6))
        temp = atomicAdd(C_de(3,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_de(ii,8)*P_de(ii,6))
        temp = atomicAdd(C_de(5,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_de(ii,8)*P_de(ii,12)*P_de(ii,6))

    end if

    h(ii) = hh
 end subroutine particles_independent
end module particles_loop